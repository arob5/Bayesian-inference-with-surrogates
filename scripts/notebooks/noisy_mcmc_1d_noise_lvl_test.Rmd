---
title: "noisy_mcmc_1d_noise_lvl_test"
output: html_document
---

```{r}
set.seed(63462)

library(data.table)
library(ggplot2)
library(patchwork)
library(scales)
library(grid)
library(support)

base_dir <- file.path("/Users/andrewroberts/Desktop/git-repos/bip-surrogates-paper")
code_dir <- file.path("/Users/andrewroberts/Desktop/git-repos/gp-calibration")
src_dir <- file.path(code_dir, "src")

# Source required files.
source(file.path(src_dir, "general_helper_functions.r"))
source(file.path(src_dir, "statistical_helper_functions.r"))
source(file.path(src_dir, "plotting_helper_functions.r"))
source(file.path(src_dir, "mcmc_helper_functions.r"))
source(file.path(src_dir, "seq_design.r"))
source(file.path(src_dir, "gp_helper_functions.r"))
source(file.path(src_dir, "gp_mcmc_functions.r"))
source(file.path(src_dir, "gpWrapper.r"))
source(file.path(src_dir, "llikEmulator.r"))
source(file.path(base_dir, "scripts", "helper", "sim_study_functions.r"))

design_pt_size <- 7
line_thickness <- 2.0

update_geom_defaults("line", list(linewidth=line_thickness))
update_geom_defaults("point", list(size=design_pt_size))

# Settings for saving plots.
save_output <- TRUE
output_dir <- file.path(base_dir, "output", "plots", "noisy_1d")

dir.create(output_dir, recursive=TRUE)
```


# Bayesian inverse problem setup.
```{r}
# Forward model.
fwd <- function(U) {
  if(is.null(dim(U))) U <- matrix(U, ncol=1L)
  colnames(U) <- "u"
  return(U)
}

# Prior.
sig2_prior <- 1
par_prior <- data.frame(dist="Gaussian", param1=0, param2=sig2_prior, lower=-Inf, upper=-Inf)
rownames(par_prior) <- "u"
lprior <- function(U) drop(dnorm(U, mean=0, sd=sqrt(sig2_prior), log=TRUE))

# Ground truth.
u_true <- 0.3
fwd_true <- fwd(u_true)

# Observed data.
n_obs <- 100L
sig2 <- 1
y <- rnorm(n=n_obs, fwd_true, sqrt(sig2))

# Log-likelihood and posterior.
llik <- function(U) {
  if(is.null(dim(U))) U <- matrix(U, ncol=1L)
  f <- function(u) sum(dnorm(y, fwd(u), sqrt(sig2), log=TRUE))
  apply(U, 1, f)
}

lpost <- function(U) llik(U) + lprior(U)
```


# Helper functions.

```{r}
get_design <- function(U) {
  design <- list(input = U)
  design$llik <- llik(design$input)
  design$lprior <- lprior(design$input)
  design$lpost <- lpost(design$input)
  design <- as.data.table(design)
  
  return(design)
}

add_trajectories <- function(plt, samp, input) {
  # Adds sample trajectories to an existing ggplot object, plotted
  # as gray lines. `samp` is (num input, num trajectories) and `input`
  # contains the x values.
  
  samp_dt <- data.table(samp)
  colnames(samp_dt) <- paste0("traj", 1:ncol(samp_dt))
  samp_dt[, input := drop(input)]
  samp_dt <- melt(samp_dt, id.vars="input", variable.name="trajectory", 
                  value.name="value")
  
  plt <- plt + geom_line(aes(x=input, y=value, group=trajectory), 
                         samp_dt, color="grey", alpha=0.7)
  
  return(plt)
}

plot_lpost_em <- function(lpost_em, grid_info, design_info, n_traj=5L, ...) {
  # Log-posterior surrogate predictions.
  U <- matrix(grid_info$input, ncol=1L)
  pred <- lpost_em$predict(U)
  q_lower <- lpost_em$calc_quantiles(U, p=0.01, ...)
  q_upper <- lpost_em$calc_quantiles(U, p=0.99, ...)

  dt_pred <- data.table(input = grid_info$input,
                        mean = pred$mean,
                        lower = q_lower,
                        upper = q_upper,
                        true = grid_info$lpost)

  # Design used to fit emulator.
  dt_design <- as.data.table(design_info)


  plt <- ggplot(dt_pred, aes(x=input)) +
          geom_ribbon(aes(ymin=lower, ymax=upper), 
                      fill="skyblue", alpha=0.4) + 
          labs(xlab="u", ylab="log-posterior")

  # Add sample trajectories.
  if(n_traj > 0) {
    samp <- lpost_em$sample(U, N_samp=n_traj, use_cov=TRUE, ...)
    plt <- add_trajectories(plt, samp, U)
  }
  
  # mean, ground truth, and design points.
  plt <- plt +
          geom_line(aes(y=mean), color="blue") +
          geom_line(aes(y=true), color="black") +
          geom_point(aes(x=input, y=lpost), dt_design, 
                     color="red", inherit.aes=FALSE)

  
  return(plt)
}


plot_post_em <- function(lpost_em, grid_info, design_info, n_traj=5L, ...) {
  # Log-posterior surrogate predictions.
  U <- matrix(grid_info$input, ncol=1L)
  pred <- lpost_em$predict_lik(U, log_scale=TRUE, ...)
  q_lower <- lpost_em$calc_lik_quantiles(U, p=0.01, log_scale=TRUE, ...)
  q_upper <- lpost_em$calc_lik_quantiles(U, p=0.99, log_scale=TRUE, ...)

  dt_pred <- data.table(input = grid_info$input,
                        mean = pred$log_mean,
                        lower = q_lower,
                        upper = q_upper,
                        true = grid_info$lpost)

  # Design used to fit emulator.
  dt_design <- as.data.table(design_info)


  plt <- ggplot(dt_pred, aes(x=input)) +
                geom_ribbon(aes(ymin=lower, ymax=upper), 
                            fill="skyblue", alpha=0.4) +
                labs(xlab="u", ylab="log-posterior")
  
  # Add sample trajectories.
  if(n_traj > 0) {
    samp <- lpost_em$sample(U, N_samp=n_traj, use_cov=TRUE, ...)
    plt <- add_trajectories(plt, samp, U)
  }
    
  # Add mean, ground truth, and design points.
  plt <- plt + 
    geom_line(aes(y=mean), color="blue") +
    geom_line(aes(y=true), color="black") +
    geom_point(aes(x=input, y=lpost), dt_design, 
               color="red", inherit.aes=FALSE)
  
  return(plt)
}


scale_lpost_var <- function(lpost_em, scale=1.0) {
  # Scales the marginal variance by multiplying by `scale`. The default of
  # 1.0 keeps the variance the same. Creates a deep copy of the emulator.
  lpost_em <- lpost_em$copy()
  new_var <- scale * lpost_em$emulator_model$gp_model$y1$nu_hat
  lpost_em$emulator_model$gp_model$y1$nu_hat <- new_var
  
  return(lpost_em)
}

```


```{r}
# Functions to compute normalized posterior density and normalized
# approximations of the posterior density. Assumes uniformly spaced
# grid.

normalize_density <- function(ldens_vals, grid, log_scale=FALSE) {
  # Given unnormalized log-density values, returns the normalized
  # density, computed using LogSumExp. If `ldens_vals` is a matrix,
  # then each row is normalized. The normalizing constant is approximated
  # by the trapezoidal rule, and assumes that `grid` is ordered in ascending
  # order (it need not be equally spaced).
  
  if(is.null(dim(ldens_vals))) ldens_vals <- matrix(ldens_vals, nrow=1L) 
  n_grid <- ncol(ldens_vals)
  
  if(n_grid != length(drop(grid))) {
    stop("`ldens_vals` and `grid` dimension mismatch.")
  }
  
  l_du <- log(diff(drop(grid)))
  log_summands_1 <- add_vec_to_mat_rows(l_du, ldens_vals[, 1:(n_grid-1), drop=FALSE])
  log_summands_2 <- add_vec_to_mat_rows(l_du, ldens_vals[, 2:n_grid, drop=FALSE])
  
  log_term_1 <- matrixStats::rowLogSumExps(log_summands_1) - log(2)
  log_term_2 <- matrixStats::rowLogSumExps(log_summands_2) - log(2)
  log_norm_csts <- matrixStats::rowLogSumExps(cbind(log_term_1, log_term_2))
  ldens_norm <- add_vec_to_mat_cols(-log_norm_csts, ldens_vals)
  
  if(log_scale) return(ldens_norm)
  return(exp(ldens_norm))
}

get_EP_dens_grid_1d <- function(lpost_em, input_grid, n_mc, log_scale=FALSE, ...) {
  
    assert_that(lpost_em$dim_input==1L)
    if(is.null(dim(input_grid))) input_grid <- matrix(input_grid, ncol=1L)
    n_grid <- nrow(input_grid)
    
    # Simulate log-likelihood values. Return shape is (n_grid, n_mc) before
    # transposing.
    lpost_samp <- t(lpost_em$sample(input_grid, N_samp=n_mc, ...))
  
    # Normalize each trajectory.
    lpost_samp_norm <- normalize_density(lpost_samp, drop(input_grid), log_scale=TRUE)
    
    # Average density over trajectories.
    lpost_ep_norm <- matrixStats::colLogSumExps(lpost_samp_norm) - log(n_mc)
    
    if(log_scale) return(lpost_ep_norm)
    return(exp(lpost_ep_norm))
}


# Exact posterior density.
get_post_exact <- function(grid_info, log_scale=FALSE) {
  drop(normalize_density(grid_info$lpost, grid_info$input, log_scale=log_scale))
}

# Plug-In mean approximation.
get_post_mean <- function(grid_info, lpost_em, log_scale=FALSE, ...) {
  U <- matrix(grid_info$input, ncol=1L)
  pred <- lpost_em$predict(U, return_var=FALSE, ...)
  
  # Normalize density.
  drop(normalize_density(pred$mean, U, log_scale=log_scale))
}

# Expected likelihood approximation.
get_post_EL <- function(grid_info, lpost_em, log_scale=FALSE, ...) {
  U <- matrix(grid_info$input, ncol=1L)
  pred <- lpost_em$predict_lik(U, return_var=FALSE, log_scale=TRUE, ...)
  
  # Normalize density.
  drop(normalize_density(pred$log_mean, U, log_scale=log_scale))
}

get_post_noisy <- function(grid_info, lpost_em, par_prior, mode="mcwmh", use_joint=TRUE,
                           n_chains=4, n_itr=10000, itr_start=7000, adjustment="rectified", 
                           lbl=NULL, ...) {

  if(is.null(lbl)) lbl <- paste(mode, ifelse(use_joint, "joint", "ind"), sep="_")
  
  ics <- get_batch_design("simple", N_batch=n_chains, prior_params=par_prior)
  mcmc_settings <- list(mcmc_func_name="mcmc_noisy_llik", par_prior=par_prior, 
                        par_init=ics, mode=mode, use_joint=use_joint, n_itr=n_itr, 
                        n_chain=n_chains, itr_start=itr_start, try_parallel=FALSE,
                        cov_prop=matrix(0.5^2), log_scale_prop=0, 
                        adapt_cov_prop=FALSE, adapt_scale_prop=FALSE,
                        llik_em=lpost_em, test_label=lbl)
  results <- do.call(run_mcmc_chains, mcmc_settings)
  
  max_rhat <- calc_R_hat(results$samp)$R_hat_vals$R_hat
  if(max_rhat > 1.05) message("Warning: R-hat above threshold.")

  return(results)
}


plot_post_comparison <- function(grid_info, design_info, lpost_em, 
                                 n_mc_EP=1e5, log_scale=FALSE, plt=NULL, ...) {
  # If existing ggplot object `plt` is passed, then adds to this plot.
  
  color_map <- c("true"="black", "mean"="#0072B2", "EL"="#E69F00", "EP"="#56B4E9", 
                 "mcwmh"="#009E73", "E-acc"="#D55E00")
  label_map <- c("true"="true", "mean"="mean", "EL"="EL", "EP"="EP", "mcwmh"="mcwmh",
                 "E-acc"="E-acc")
  
  dt <- data.table(input = drop(grid_info$input),
                   true = get_post_exact(grid_info, log_scale=log_scale),
                   mean = get_post_mean(grid_info, lpost_em, log_scale=log_scale, ...),
                   EL = get_post_EL(grid_info, lpost_em, log_scale=log_scale, ...),
                   EP = get_EP_dens_grid_1d(lpost_em, grid_info$input, n_mc=n_mc_EP, 
                                            log_scale=log_scale, ...))
  dt <- melt(dt, id.vars="input", variable.name="post", value.name="value")

  if(is.null(plt)) plt <- ggplot()
  
  plt <- plt + 
          geom_line(aes(x=input, y=value, color=post), data=dt, inherit.aes=FALSE) + 
          geom_vline(xintercept=design_info$input, color="red", linetype="dashed") +
          labs(x="u", y="posterior") +
          scale_color_manual(values=color_map, labels=label_map)
}

```


# Grid for plotting and design points.
```{r}
n_grid <- 100L
p_grid <- .99
grid_min <- -3
grid_max <- 3

# Design.
design_info <- get_design(qnorm(c(.1, .5, .9), sd=sqrt(sig2_prior)))

# Include design points in grid.
grid_inputs <- sort(c(design_info$input, seq(grid_min, grid_max, length.out=n_grid)))
grid_info <- get_design(grid_inputs)
grid_info_dt <- as.data.table(grid_info)
input_grid <- matrix(grid_info$input, ncol=1L)
```

```{r}
# Plot exact quantities.
plt_exact <- ggplot(grid_info_dt, aes(x=input)) +
              geom_line(aes(y=llik), color="blue") +
              geom_line(aes(y=lprior), color="red") +
              geom_line(aes(y=lpost), color="black")

plot(plt_exact)
```

# Log-likelihood emulation. 
```{r}
# Function to fit llik emulator.

fit_llik_em <- function(design) {
  # Fit GP.
  gp <- gpWrapperHet(matrix(design$input, ncol=1L), 
                     matrix(design$llik, ncol=1L),
                     scale_input=TRUE, normalize_output=TRUE)
  gp$set_gp_prior("Gaussian", "constant", include_noise=FALSE)
  gp$fit()
  
  # Create llikEmulator object. Shifting the mean so that the predictions
  # are for the log-posterior.
  lpost_em <- llikEmulatorGP("em_llik", gp, default_conditional=FALSE, 
                             default_normalize=TRUE, shift_func=lprior, 
                             is_lpost_em=TRUE)
}

```


```{r}
# Fit log-likelihood emulator (no bound constraint enforced).
lpost_em <- fit_llik_em(design_info)

# Second emulator that enforces bound constraint. Gaussian log-likelihood is 
# bounded above by the log-determinant term.
lpost_bound <- function(U) lprior(U) - 0.5 * n_obs * log(2*pi*sig2)
dt_bound <- data.table(input=grid_info$input, bound=lpost_bound(input_grid))
lpost_em_bounded <- lpost_em$copy()
lpost_em_bounded$llik_bounds <- function(U, ...) {
  list(lower = -Inf, upper = lpost_bound(U))
}
```

```{r}
# TODO: compare to a version where the design points are moved farther out.

# lpost em. 
plt_lpost <- plot_lpost_em(lpost_em, grid_info, design_info)
plt_lpost_rect <- plot_lpost_em(lpost_em_bounded, grid_info, design_info, adjustment="rectified")

# Format
plt_lpost <- plt_lpost + 
              geom_line(aes(x=input, y=bound), dt_bound, color="green", linetype="dashed") +
              labs(x="u", y="log-post")
plt_lpost <- ggformat_journal(plt_lpost, remove_title=TRUE)

plt_lpost_rect <- plt_lpost_rect + 
                  geom_line(aes(x=input, y=bound), dt_bound, color="green", linetype="dashed") +
                  labs(x="u", y="log-post")
plt_lpost_rect <- ggformat_journal(plt_lpost_rect, remove_title=TRUE) 

plot(plt_lpost)
plot(plt_lpost_rect)

# Save plots.
if(save_output) {
  ggsave(file.path(output_dir, "lpost_em_dist.png"), plt_lpost)
  ggsave(file.path(output_dir, "lpost_em_rect_dist.png"), plt_lpost_rect)
}
```


```{r}
# Unnormalized posterior emulator (on log scale).
plt_post <- plot_post_em(lpost_em, grid_info, design_info)
plt_post_rect <- plot_post_em(lpost_em_bounded, grid_info, design_info, adjustment="rectified")

# Format
plt_post <- plt_post + 
              geom_line(aes(x=input, y=bound), dt_bound, color="green", linetype="dashed") +
              labs(x="u", y="log-post")
plt_post <- ggformat_journal(plt_post, remove_title=TRUE)

plt_post_rect <- plt_post_rect + 
                  geom_line(aes(x=input, y=bound), dt_bound, color="green", linetype="dashed") +
                  labs(x="u", y="log-post")
plt_post_rect <- ggformat_journal(plt_post_rect, remove_title=TRUE) 

plot(plt_post)
plot(plt_post_rect)

# Save plots.
if(save_output) {
  ggsave(file.path(output_dir, "post_em_dist.png"), plt_post)
  ggsave(file.path(output_dir, "post_em_rect_dist.png"), plt_post_rect)
}
```

```{r}
# Noisy MCMC posterior approximations.

# Truncating prior based on grid bounds (bounds contain almost all prior mass).
par_prior <- data.frame(dist="Truncated_Gaussian", param1=0, 
                        param2=sqrt(sig2_prior), bound_lower=min(input_grid), 
                        bound_upper=max(input_grid))
rownames(par_prior) <- "u"
n_chains <- 4L

# Run noisy MCMC samplers.
Eacc_results <- get_post_noisy(grid_info, lpost_em, par_prior, mode="mcwmh", 
                               use_joint=TRUE, lbl="E-acc")
Eacc_results_rect <- get_post_noisy(grid_info, lpost_em_bounded, par_prior, 
                                    mode="mcwmh", use_joint=TRUE, lbl="E-acc")
mcwmh_results <- get_post_noisy(grid_info, lpost_em, par_prior, mode="mcwmh",
                                use_joint=FALSE, lbl="mcwmh")
mcwmh_results_rect <- get_post_noisy(grid_info, lpost_em_bounded, par_prior, 
                                     mode="mcwmh", use_joint=FALSE, lbl="mcwmh")

# Combine samples.
noisy_mcmc_dt <- combine_samp_dt(Eacc_results$samp, mcwmh_results$samp)
noisy_mcmc_dt_rect <- combine_samp_dt(Eacc_results_rect$samp, mcwmh_results_rect$samp)

# KDE plot. 
kde_plt <- get_1d_kde_plots(noisy_mcmc_dt, line_thickness=line_thickness)[[1]]
kde_plt_rect <- get_1d_kde_plots(noisy_mcmc_dt_rect, line_thickness=line_thickness)[[1]]

plot(kde_plt)
plot(kde_plt_rect)
```

```{r}
# MCMC diagnostics.
trace_plots <- get_trace_plots(noisy_mcmc_dt)
hist_plots <- get_hist_plots(noisy_mcmc_dt)

for(plt in trace_plots) plot(plt)
for(plt in hist_plots) plot(plt)
```


```{r}
# Observations: the EP approx is not very sensitive to whether or not the predictive 
# distribution is bounded, while the EL approx is very sensitive. When bounded, the EL
# approx closely resembles the EP approx.

plt_post_comparison <- plot_post_comparison(grid_info, design_info, lpost_em, plt=kde_plt)
plt_post_comparison_trunc <- plot_post_comparison(grid_info, design_info, 
                                                  lpost_em_bounded, adjustment="truncated")
plt_post_comparison_rect <- plot_post_comparison(grid_info, design_info, lpost_em_bounded,
                                                 adjustment="rectified", plt=kde_plt_rect)

# Format.
plt_post_comparison <- ggformat_journal(plt_post_comparison,
                                        remove_title=TRUE,
                                        legend_position=c(0.98, 0.98),
                                        legend.justification=c("right", "top"),
                                        legend.direction="vertical",
                                        legend_size=27)
plt_post_comparison_rect <- ggformat_journal(plt_post_comparison_rect,
                                             remove_title=TRUE,
                                             legend_position=c(0.98, 0.98),
                                             legend.justification=c("right", "top"),
                                             legend.direction="vertical",
                                             legend_size=27)


plot(plt_post_comparison)
plot(plt_post_comparison_rect)
plot(plt_post_comparison_trunc)

# Save plots.
if(save_output) {
  ggsave(file.path(output_dir, "post_comparison.png"), plt_post_comparison)
  ggsave(file.path(output_dir, "post_comparison_rect.png"), plt_post_comparison_rect)
}
```







