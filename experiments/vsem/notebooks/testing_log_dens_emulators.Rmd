---
title: "Testing Log-Density Emulators for VSEM Inverse Problem"
output: html_document
---

```{r}
set.seed(543653)

library(data.table)
library(ggplot2)
library(patchwork)
library(scales)
library(grid)
library(support)

experiment_tag <- "vsem"
write_plots <- TRUE

base_dir <- file.path("/projectnb", "dietzelab", "arober", "bip-surrogates-paper")
code_dir <- file.path("/projectnb", "dietzelab", "arober", "gp-calibration")
src_dir <- file.path(code_dir, "src")
experiment_dir <- file.path(base_dir, "experiments", experiment_tag)
out_dir <- file.path(experiment_dir, "output", "inv_prob_setup")
alg_settings_dir <- file.path(experiment_dir, "output", "alg_settings")
plt_dir <- file.path(out_dir, "plots")

# Source required files.
source(file.path(src_dir, "general_helper_functions.r"))
source(file.path(src_dir, "statistical_helper_functions.r"))
source(file.path(src_dir, "inv_prob_test_functions.r"))
source(file.path(src_dir, "plotting_helper_functions.r"))
source(file.path(src_dir, "mcmc_helper_functions.r"))
source(file.path(src_dir, "seq_design.r"))
source(file.path(src_dir, "gp_helper_functions.r"))
source(file.path(src_dir, "gp_mcmc_functions.r"))
source(file.path(src_dir, "gpWrapper.r"))
source(file.path(src_dir, "llikEmulator.r"))
source(file.path(base_dir, "scripts", "helper", "sim_study_functions.r"))
source(file.path(base_dir, "..", "sipnet_calibration", "src", "prob_dists.r"))
source(file.path(base_dir, "..", "sipnet_calibration", "src", "eki_pecan.r"))
```

```{r}
# Read data/plots saved to file.
samp_dt <- fread(file.path(out_dir, "samp_exact.csv"))
samp_dt_prior <- fread(file.path(out_dir, "prior_samp.csv"))
inv_prob <- readRDS(file.path(out_dir, "inv_prob_list.rds"))
test_info_prior <- readRDS(file.path(out_dir, "test_info_prior.rds"))
test_info_post <- readRDS(file.path(out_dir, "test_info_post.rds"))
em_settings <- readRDS(file.path(alg_settings_dir, "em_settings.rds"))

par_prior <- inv_prob$par_prior
lprior <- get_lprior_dens(par_prior)
llik_obj <- inv_prob$llik_obj
lpost <- function(U) lprior(U) + llik_obj$assemble_llik(U)
```


# Investigate use of EKI to define mean function for emulator

```{r}
# Initial design: sampling majority of points from the prior, which will be 
# used for constructing the GP trend.
design_inputs <- get_batch_design("LHS", N_batch=50L, 
                                  prior_params=par_prior)
design <- get_init_design_list(inv_prob, "LHS", 50, inputs=design_inputs)
```

```{r}
# Run single-step EKI.

# Inputs to EKI algorithm.
Sig <- diag(llik_obj$lik_par, nrow=inv_prob$dim_obs, ncol=inv_prob$dim_obs)
fwd_eki <- function(U, ...) inv_prob$par_to_obs_op(U)
prior_list <- convert_par_info_to_list(par_prior)
par_maps <- get_par_map_funcs(prior_list)

# Run EKI.
eki_results <- run_eki_pecan(drop(inv_prob$y), fwd_eki, Sig, 
                             prior_list, n_itr=1L, U0=design$input)

# Combine EKI samples with posterior and prior samples.
samp_dt_comb <- combine_samp_dt(samp_dt, samp_dt_prior)
samp_dt_comb <- append_samples_mat(samp_dt_comb, eki_results$U, param_type="par",
                                   test_label="eki")
```


```{r}
# Plot prior, posterior, and EKI marginals.
kde_plots <- get_1d_kde_plots(samp_dt_comb, test_label_baseline="prior")

for(plt in kde_plots) plot(plt)
```
# Use GP to set "extrapolation/exploration" points in the tails of the EKI
# posterior approximation.
```{r}
# Compute marginal quantiles of EKI approximation of u|[y=y_obs].
eki_moments <- get_Gaussian_cond_moments(eki_results, drop(inv_prob$y))
eki_quantiles <- rep(NA, inv_prob$dim_par)
for(i in seq_len(inv_prob$dim_par)) {
  eki_quantiles[i] <- qnorm(.9999, mean=drop(eki_moments$mean)[i], 
                            sd=sqrt(eki_moments$cov[i,i]))
}

# Transform back to original space (note that this relies on the assumption
# that the component-wise parameter transformations are monotonic increasing).
eki_quantiles <- matrix(eki_quantiles, nrow=1L, dimnames=list(NULL, rownames(eki_moments$mean))) 
eki_quantiles <- par_maps$inv(eki_quantiles)

print("EKI quantiles:")
print(eki_quantiles)

print("Existing design point bounds:")
print(get_bounds(design$input))
```
```{r}
# Include design points at the EKI quantiles. Sampling the bounded parameters
# from the prior and only including points at the quantiles of the unbounded
# parameters (tauV and Cv). For tauV, there is a gap between the existing
# design bound and the EKI quantile, so we aim to populate this in-between 
# area, rather than just placing points at the quantile.
extrap_inputs <- get_batch_design("LHS", N_batch=10L, prior_params=par_prior)
tauV_only_idx <- 1:3
Cv_only_idx <- 4:6
tauV_Cv_idx <- 7:10
n_tauv <- length(c(tauV_only_idx, tauV_Cv_idx))
tauv_new <- seq(get_bounds(design$input)[2,"tauV"], eki_quantiles[,"tauV"], length.out=n_tauv)

extrap_inputs[c(tauV_only_idx, tauV_Cv_idx),"tauV"] <- tauv_new
extrap_inputs[c(Cv_only_idx, tauV_Cv_idx),"Cv"] <- eki_quantiles[,"Cv"] 

print(extrap_inputs)
```

```{r}
# Add new points to design.
design_comb <- get_init_design_list(inv_prob, "LHS", 60, inputs=rbind(design_inputs, extrap_inputs))

# Create truncated prior based on EKI quantiles.
par_prior_trunc <- par_prior
par_prior_trunc["tauV", "bound_upper"] <- eki_quantiles[,"tauV"]
par_prior_trunc["Cv", "bound_upper"] <- eki_quantiles[,"Cv"]
```


```{r}
# Old method of adding extrapolation points.
# unbounded_pars <- c("tauV", "Cv")
# lprior_unbounded <- calc_lprior_dens(design_inputs[,unbounded_pars], 
#                                      par_prior=par_prior[unbounded_pars,])
# extrap_candidates <- get_batch_design("LHS", N_batch=1e5, prior_params=par_prior)
# lprior_unbounded_cand <- calc_lprior_dens(extrap_candidates[,unbounded_pars], 
#                                           par_prior=par_prior[unbounded_pars,])
# tail_pts_idx <- which(lprior_unbounded_cand < min(lprior_unbounded))
# extrap_idx <- sample(tail_pts_idx, size=10L, replace=FALSE)
# extrap_inputs <- extrap_candidates[extrap_idx,]
# 
# design_comb <- get_init_design_list(inv_prob, "LHS", 80, inputs=rbind(design_inputs, extrap_inputs))
```


```{r}
# Bivariate marginals.
dens_2d_plots <- get_2d_density_plots(samp_dt_comb)
```

```{r}
# Exact MCMC
for(plt in dens_2d_plots$exact) plot(plt)
```

```{r}
# EKI
for(plt in dens_2d_plots$eki) plot(plt)
```

## Using EKI Gaussian ansatz as mean function

```{r}
# EKI density approximation in transformed phi-space and original space.
lpost_phi_eki <- get_Gaussian_ldens_approx(eki_results, drop(inv_prob$y),
                                           transform=FALSE, normalize=FALSE)
lpost_eki <- get_Gaussian_ldens_approx(eki_results, drop(inv_prob$y),
                                       transform=TRUE, normalize=FALSE)

# Construct density of transformed (unconstrained) variables.
lprior_phi <- function(phi) {
  par <- par_maps$inv(phi)
  log_det_J <- attr(par, "log_det_J")
  
  lprior(par) + log_det_J
}

# Adjust llik to account for parameter transformation.
llik_phi <- function(phi, ...) {
  llik_obj$assemble_llik(par_maps$inv(phi), ...)
}

# Log-unnormalized posterior density as function of transformed parameter.
lpost_phi <- function(phi) lprior_phi(phi) + llik_phi(phi)
```


```{r}
# Prepare points for plotting projections.
par_maps <- eki_results$par_maps
prior_bounds <- get_prior_bounds(par_prior, tail_prob_excluded=0.000001)
fixed_vals <- sample_prior(par_prior, n=5L)
input_grids <- get_input_grid_1d_projection(inv_prob$par_names, 
                                            X_fixed=fixed_vals,
                                            X_bounds=prior_bounds, 
                                            n_points_default=300L)

# In transformed space.
input_grids_phi <- list()
for(i in seq_along(input_grids)) {
  par_name <- names(input_grids)[i]
  input_grids_phi[[par_name]] <- list()
  
  for(j in seq_along(input_grids[[i]])) {
    input_grids_phi[[par_name]][[j]] <- par_maps$fwd(input_grids[[par_name]][[j]])
  }
}

names(input_grids_phi) <- colnames(input_grids_phi[[1]][[1]])
```

```{r}
# Exact Log posterior.
proj_lpost_plots <- plot_1d_proj(lpost, input_grids=input_grids)

# EKI approximation.
proj_lpost_plots_eki <- plot_1d_proj(lpost_eki, input_grids=input_grids)
```

```{r}
for(plt in proj_lpost_plots) plot(plt)
```

```{r}
for(plt in proj_lpost_plots_eki) plot(plt)
```

```{r}
# Exact Log posterior as function of transformed parameter.
proj_lpost_phi_plots <- plot_1d_proj(lpost_phi, input_grids=input_grids_phi)

# EKI approximation as function of untransformed parameter.
proj_lpost_phi_plots_eki <- plot_1d_proj(lpost_phi_eki, input_grids=input_grids_phi)
```

```{r}
for(plt in proj_lpost_phi_plots) plot(plt)
```

```{r}
for(plt in proj_lpost_phi_plots_eki) plot(plt)
```


# Comparing EKI density to true density.

```{r}
# Comparing at points sampled from the prior.
lpost_eki_prior_pred <- lpost_eki(test_info_prior$input)
lpost_eki_post_pred <- lpost_eki(test_info_post$input)
```

```{r}
# Plot predictions at prior points.
dt_plt_eki_trend_prior <- data.table(test_info_prior$input,
                                     true=test_info_prior$lpost,
                                     eki=lpost_eki_prior_pred)

plt_eki_prior_pred <- ggplot(dt_plt_eki_trend_prior) +
                        geom_point(aes(x=true, y=eki)) +
                        geom_abline(slope=1, intercept=0, color="red")

plot(plt_eki_prior_pred)
```

```{r}
# Plot predictions at posterior points.
dt_plt_eki_trend_post <- data.table(test_info_post$input,
                                    true=test_info_post$lpost,
                                    eki=lpost_eki_post_pred)

plt_eki_post_pred <- ggplot(dt_plt_eki_trend_post) +
                        geom_point(aes(x=true, y=eki)) +
                        geom_abline(slope=1, intercept=0, color="red")

plot(plt_eki_post_pred)
```

# Fit log-posterior emulator

```{r}
resids <- design_comb$lpost - lpost_eki(design_comb$input)
print(quantile(resids, seq(.1, 1, .1)))

# Fit GP.
gp_obj <- gpWrapperHet(design_comb$input, matrix(resids, ncol=1L),
                       scale_input=TRUE, normalize_output=TRUE)
gp_obj$set_gp_prior("Gaussian", "constant", include_noise=FALSE)
gp_obj$fit()

marg_sd <- sqrt(gp_obj$gp_model$y1$nu_hat) * gp_obj$Y_std
print(paste0("GP marginal sd: ", marg_sd))

# Create llikEmulator object. Note that this actually constitutes a log-posterior
# emulator. The shift accounts for the mean function.
lpost_bounds <- function(U) {
  llik_bounds <- llik_obj$get_llik_bounds()
  lprior_vals <- lprior(U)
  list(lower=llik_bounds[1]+lprior_vals, upper=llik_bounds[2]+lprior_vals)
}

lpost_em <- llikEmulatorGP("em_lpost", gp_obj, default_conditional=FALSE, 
                           default_normalize=TRUE, 
                           lik_par=inv_prob$llik_obj$get_lik_par(), 
                           shift_func=lpost_eki, llik_bounds=lpost_bounds,
                           is_lpost_em=TRUE)

```

```{r}
# Predictions at prior and posterior points.
lpost_scatter_prior <- lpost_em$plot_pred_validation(test_info_prior$input, 
                                                     adjustment="rectified",
                                                     true_llik=test_info_prior$lpost, 
                                                     interval_method="CI", CI_prob=0.9)
lpost_scatter_post <- lpost_em$plot_pred_validation(test_info_post$input,
                                                    adjustment="rectified",
                                                    true_llik=test_info_post$lpost, 
                                                    interval_method="CI", CI_prob=0.9)

# Format plots.
lpost_scatter_prior <- ggformat_journal(lpost_scatter_prior, remove_title=TRUE)
lpost_scatter_post <- ggformat_journal(lpost_scatter_post, remove_title=TRUE)

plot(lpost_scatter_prior)
plot(lpost_scatter_post)

if(write_plots) {
  ggsave(file.path(plt_dir, "pred_scatter_prior_lpostem.png"), lpost_scatter_prior)
  ggsave(file.path(plt_dir, "pred_scatter_post_lpostem.png"), lpost_scatter_post)
}

# lpost_scatter_prior +
#   annotate("label", x=-2000, y=0, label="rmse: 10\ncrps: 5\nlog-score: 4",
#             hjust=0, vjust=1, label.size=0.3, label.r=unit(0.2, "lines"),
#             size=8)
```

```{r}
# Looking out farther in the tails.
prior_bounds2 <- prior_bounds
prior_bounds2[2,"tauV"] <- 10000
prior_bounds2[2, "Cv"] <- 30
input_grids2 <- get_input_grid_1d_projection(inv_prob$par_names, 
                                             X_fixed=fixed_vals,
                                             X_bounds=prior_bounds2, 
                                             n_points_default=300L)

# Plot one-dimensional projections of log-posterior density emulator (on log scale).
lpost_em_quantile <- function(U) lpost_em$calc_quantiles(U, p=0.95, adjustment="rectified")
lpost_em_extrap_plots <- plot_1d_proj(lpost_em_quantile, input_grids=input_grids2)

# Plot one-dimensional projections of posterior density emulator (on log scale).
# TODO: what is going on with Cv-fixed2 around Cv in [10,15]. Quantile is flat.
# post_em_extrap_plots <- lpost_em$plot_1d_proj_approx_lik(input_grids=input_grids2, 
#                                                          approx_type="quantile",
#                                                          alpha=0.9, 
#                                                          adjustment="rectified")

design_bounds <- get_bounds(lpost_em$get_design_inputs())
design_bounds[2,] <- drop(eki_quantiles)

for(i in seq_along(lpost_em_extrap_plots)) {
  par_name <- names(lpost_em_extrap_plots)[i]
  design_bounds_par <- design_bounds[,par_name]
  plt <- lpost_em_extrap_plots[[i]] + 
          geom_vline(xintercept=design_bounds_par[1], color="grey", linetype="dashed", linewidth=2) +
          geom_vline(xintercept=design_bounds_par[2], color="grey", linetype="dashed", linewidth=2) +
          labs(y="Quantile")
  plt <- ggformat_journal(plt, remove_title=TRUE)
  plot(plt)
  
  if(write_plots) {
    ggsave(file.path(plt_dir, paste0("extrap_q95_lpostem_", par_name, ".png")), plt)
  }
}
```

# Posterior Approximation
```{r}
# MCMC settings.
cov_prop_init <- cov(design_comb$input)
n_chains <- 4L

# mcwmh-joint.
mcmc_settings <- list(test_label="mcwmh-joint", 
                      mcmc_func_name="mcmc_noisy_llik", llik_em=lpost_em,
                      par_prior=par_prior_trunc, mode="mcwmh", use_joint=TRUE, 
                      n_avg=10L, n_itr=20000L, itr_start=10000, n_chain=n_chains, 
                      try_parallel=TRUE, cov_prop=cov_prop_init, adjustment="rectified")
mcmc_approx_mcwmh <- do.call(run_mcmc_chains, mcmc_settings)
samp_dt_mcwmh <- mcmc_approx_mcwmh$samp

# expected likelihood.
mcmc_settings <- list(test_label="EL", 
                      mcmc_func_name="mcmc_gp_unn_post_dens_approx", llik_em=lpost_em,
                      par_prior=par_prior_trunc, approx_type="marginal", 
                      n_itr=20000L, itr_start=10000, n_chain=n_chains, 
                      try_parallel=TRUE, cov_prop=cov_prop_init, adjustment="rectified")
mcmc_approx_EL <- do.call(run_mcmc_chains, mcmc_settings)
samp_dt_EL <- mcmc_approx_EL$samp

# plug-in mean.
mcmc_settings <- list(test_label="mean", 
                      mcmc_func_name="mcmc_gp_unn_post_dens_approx", llik_em=lpost_em,
                      par_prior=par_prior_trunc, approx_type="mean", 
                      n_itr=20000L, itr_start=10000, n_chain=n_chains, 
                      try_parallel=TRUE, cov_prop=cov_prop_init, adjustment="rectified")
mcmc_approx_mean <- do.call(run_mcmc_chains, mcmc_settings)
samp_dt_mean <- mcmc_approx_mean$samp

# Combine samples.
mcmc_dt_approx <- combine_samp_dt(samp_dt_mcwmh, samp_dt_EL, samp_dt_mean)
info_dt_approx <- combine_samp_dt(mcmc_approx_mcwmh$info, mcmc_approx_EL$info, 
                                  mcmc_approx_mean$info)

saveRDS(mcmc_dt_approx, file.path(out_dir, "..", "mcmc_dt_approx.rds"))
saveRDS(info_dt_approx, file.path(out_dir, "..", "info_dt_approx.rds"))
```

```{r}
trace_plts <- get_trace_plots(mcmc_dt_approx)
lpost_trace <- get_trace_plots(info_dt_approx, param_type="dens", param_names="llik")

for(plt in trace_plts) plot(plt)
for(plt in lpost_trace) plot(plt)
```

```{r}
mcmc_dt_approx <- mcmc_dt_approx[!((test_label=="mcwmh-joint") & (chain_idx==2L))]
samp_dt_comb <- combine_samp_dt(samp_dt_comb, mcmc_dt_approx)
samp_dt_comb[test_label=="mcwmh-joint", test_label := "E-acc"]

kde_mean_approx <- get_1d_kde_plots(samp_dt_comb, test_label_baseline="exact",
                                    test_labels="mean")
kde_other_approx <- get_1d_kde_plots(samp_dt_comb, test_label_baseline="exact",
                                     test_labels=c("E-acc", "EL"))

for(i in seq_along(kde_mean_approx)) {
  par_name <- names(kde_mean_approx)[i]
  plt <- kde_mean_approx[[i]] + labs(y="density", color="Post Approx")
  plt <- ggformat_journal(plt, remove_title=TRUE, legend_position=c(1,1), 
                          legend.justification=c(1,1))
  plot(plt)
  
  if(write_plots) ggsave(file.path(plt_dir, paste0("kde_mean_approx_", par_name, ".png")))
}

for(i in seq_along(kde_other_approx)) {
  par_name <- names(kde_other_approx)[i]
  plt <- kde_other_approx[[i]] + labs(y="density", color="Post Approx")
  plt <- ggformat_journal(plt, remove_title=TRUE, legend_position=c(1,1), 
                          legend.justification=c(1,1))
  plot(plt)
  
  if(write_plots) ggsave(file.path(plt_dir, paste0("kde_other_approx_", par_name, ".png")))
}
```


```{r}
lpost_test <- function(U, ...) lpost_eki(U) - lprior(U)

test <- run_mcmc_pecan(lpost_test, prior_list, 20000L, n_chains=1L, prop_settings=NULL)
test_samp <- eki_results$par_maps$inv(test$samp$par)

samp_dt_test <- format_samples_mat(test_samp, param_type="par", test_label="test")

trace_plots_test <- get_trace_plots(samp_dt_test)
for(plt in trace_plots_test) plot(plt)

samp_dt_test <- select_mcmc_itr(samp_dt_test, itr_start=10000)
```

```{r}
# Quantiles of samples.
apply(test_samp, 2, function(x) quantile(x, .99))
apply(test_samp, 2, function(x) quantile(x, .01))
```

```{r}
samp_dt_comb <- combine_samp_dt(samp_dt_comb, samp_dt_test)
```


```{r}
kde_test <- get_1d_kde_plots(samp_dt_comb, test_label_baseline="prior",
                             test_labels=c("exact", "eki", "test"))

for(plt in kde_test) plot(plt)
```








